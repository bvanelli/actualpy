# Experimental features

!!! danger
    Experimental features do not have all the testing necessary to ensure correctness in comparison to the
    files generated by the Javascript API. This means that this operations could in theory corrupt the data. Make sure
    you have backups of your data before trying any of those operations.

## Bootstraping a new server and uploading a first file

The following script would generate a new empty budget on the Actual server, even if the server was not bootstrapped
with an initial password.

```python
from actual import Actual

with Actual(base_url="http://localhost:5006", password="mypass", bootstrap=True) as actual:
    actual.create_budget("My budget")
    actual.upload_budget()
```

You will then have a freshly created new budget to use:

![created-budget](./static/new-budget.png?raw=true)

If the `encryption_password` is set, the budget will additionally also be encrypted on the upload step to the server.

## Updating transactions using Bank Sync

If you have either [goCardless](https://actualbudget.org/docs/advanced/bank-sync/#gocardless-setup) or
[simplefin](https://actualbudget.org/docs/experimental/simplefin-sync/) integration configured, it is possible to
update the transactions using just the Python API alone. This is because the actual queries to the third-party service
are handled on the server, so the client does not have to do any custom API queries.

To sync your account, simply call the `run_bank_sync` method:

```python
from actual import Actual

with Actual(base_url="http://localhost:5006", password="mypass") as actual:
    synchronized_transactions = actual.run_bank_sync()
    for transaction in synchronized_transactions:
        print(f"Added of modified {transaction}")
    # sync changes back to the server
    actual.commit()

```

## Running rules

Rules can be rune individually via the library. You can filter which rules are going to be run, but also check
beforehand which rules actually are going to run, similar to the preview function from Actual.

The most simple case is to run all rules for all transactions at once. This is equivalent as "Apply Actions" for all
rules on frontend:

```python
from actual import Actual
from actual.queries import get_ruleset

with Actual(base_url="http://localhost:5006", password="mypass", file="My budget") as actual:
    # print all rules and their human-readable descriptions
    print(get_ruleset(actual.session))
    # run all rules
    actual.run_rules()
    # sync changes back to the server
    actual.commit()
```

You can also manipulate the rules individually, and validate each rule that runs for each transaction, allowing you
to also debug rules. This can be useful when more than one rule is modifying the same transaction, but the order of
operations is not correct:

```python
from actual import Actual
from actual.queries import get_ruleset, get_transactions

with Actual(base_url="http://localhost:5006", password="mypass", file="My budget") as actual:
    ruleset = get_ruleset(actual.session)
    transactions = get_transactions(actual.session)
    for rule in ruleset:
        for t in transactions:
            if rule.evaluate(t):
                print(f"Rule {rule} matches for {t}")
                # if you are happy with the result from the rule, apply it
                rule.run(t)
    # if you want to sync the changes back to the server, uncomment the following line
    # actual.commit()
```

If you are importing transactions, the rules are not running automatically. For that reason, you might need to run them
individually. Use the [RuleSet.run][actual.rules.RuleSet.run] for that purpose, to run the rule after creating the
transaction:

```python
from actual import Actual
from actual.queries import get_ruleset, reconcile_transaction
from datetime import date

with Actual(base_url="http://localhost:5006", password="mypass", file="My budget") as actual:
    ruleset = get_ruleset(actual.session)
    # we create one transaction
    t = reconcile_transaction(actual.session, date.today(), "Bank", "", notes="Coffee", amount=-4.50)
    # run the rules on the newly created transaction
    ruleset.run(t)
    # send the changes back to the server
    actual.commit()
```
